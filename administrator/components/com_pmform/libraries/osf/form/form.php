<?php
/**
 * Form Class for handling custom fields
 * 
 * @package		POSF
 * @subpackage  Form  
 */
class POSFForm
{
	/**
	 * Form amount
	 *
	 * @var float
	 */
	protected $amount = 0;
	/**
	 * The array hold list of custom fields
	 * 
	 * @var array
	 */
	protected $fields;
	/**
	 * Constructor 
	 * 
	 * @param array $fields
	 */
	public function __construct($fields, $config = array())
	{
		foreach ($fields as $field)
		{
			$class = 'POSFFormField' . ucfirst($field->fieldtype);
			if (class_exists($class))
			{
				$this->fields[$field->name] = new $class($field, $field->default_values);
			}
			else
			{
				throw new RuntimeException('The field type ' . $field->fieldType . ' is not supported');
			}
		}
	}

	/**
	 * Get fields of form
	 *
	 * @return array
	 */
	public function getFields()
	{
		return $this->fields;
	}

	/**
	 * Set fields array for the form
	 *
	 * @param $fields
	 */
	public function setFields($fields)
	{
		$this->fields = $fields;
	}
	/**
	 * Get the field object from name
	 * @param string $name
	 * @return POSFFormField
	 */
	public function getField($name)
	{
		return $this->fields[$name];	
	}

	/**
	 *
	 * @param $name
	 */
	public function removeField($name)
	{
		if (isset($this->fields[$name]))
		{
			unset($this->fields[$name]);
		}
	}
	/**
	 *
	 * Bind data into form fields
	 *
	 * @param array $data
	 * @param bool $useDefault
	 */
	public function bind($data, $useDefault = false)
	{
		foreach ($this->fields as $field)
		{
			if (isset($data[$field->name]))
			{
				$field->setValue($data[$field->name]);
			}
			else
			{
				if ($useDefault)
				{
					$field->setValue($field->default_values);
				}
				else
				{
					$field->setValue(null);
				}
			}
		}
		return $this;
	}

	/**
	 * Check if the form contains fee fields or not
	 *
	 * @return boolean
	 */
	public function containFeeFields()
	{
		$containFeeFields = false;
		foreach ($this->fields as $field)
		{
			if ($field->fee_field)
			{
				$containFeeFields = true;
				break;
			}
		}
		return $containFeeFields;
	}

    /**
     * Prepare form fields before being displayed. We need to calculate to see what fields are shown, what fields are hided
     *
     * @param int $campaignId
     */
    public function prepareFormField()
    {

	    $feeFormula = '';
	    foreach ($this->fields as $field)
	    {
		    if ($field->fee_formula)
		    {
			    $feeFormula .= $field->fee_formula;
		    }
	    }
	    foreach ($this->fields as $field)
	    {
		    if ($field->fee_field || strpos($feeFormula, '[' . strtoupper($field->name) . ']') !== FALSE)
		    {
			    $field->setFeeCalculation(true);
			    switch ($field->type)
			    {
				    case 'List':
				    case 'Text':
					    $field->setAttribute('onchange', 'calculateFormFee();');
					    break;
				    case 'Checkboxes':
				    case 'Radio':
					    $field->setAttribute('onclick', 'calculateFormFee();');
					    break;
			    }
		    }
	    }
    }


	/**
	 * Build the custom field dependency
	 *
	 */
	public function buildFieldsDependency()
	{
		$masterFields = array();
		$fieldsAssoc = array();
		foreach ($this->fields as $field)
		{
			if ($field->depend_on_field_id)
			{
				$masterFields[] = $field->depend_on_field_id;
			}
			$fieldsAssoc[$field->id] = $field;
		}
		if (count($masterFields))
		{
			foreach ($this->fields as $field)
			{
				if (in_array($field->id, $masterFields))
				{
					$field->setFeeCalculation(true);
					switch (strtolower($field->type))
					{
						case 'list':
							$field->setAttribute('onchange', "showHideDependFields($field->id, '$field->name', '$field->type');");
							break;
						case 'radio':
						case 'checkboxes':
							$field->setAttribute('onclick', "showHideDependFields($field->id, '$field->name', '$field->type');");
							break;
					}
				}
				elseif ($field->depend_on_field_id && isset($fieldsAssoc[$field->depend_on_field_id]))
				{
					$masterFieldValues = $fieldsAssoc[$field->depend_on_field_id]->value;
					if (is_array($masterFieldValues))
					{
						$selectedOptions = $masterFieldValues;
					}
					elseif (strpos($masterFieldValues, "\r\n"))
					{
						$selectedOptions = explode("\r\n", $masterFieldValues);
					}
					elseif (is_string($masterFieldValues) && is_array(json_decode($masterFieldValues)))
					{
						$selectedOptions = json_decode($masterFieldValues);
					}
					else
					{
						$selectedOptions = array($masterFieldValues);
					}
					$dependOnOptions = explode(',', $field->depend_on_options);
					if (!count(array_intersect($selectedOptions, $dependOnOptions)))
					{
						$field->setVisibility(false);
					}
				}
			}
		}
	}

	/**
	 * Calculate total fee generated by all fields on the form
	 *
	 * @return float total fee
	 */
	public function calculateFee()
	{
		$fee = 0;
		$this->buildFieldsDependency();
		$fieldsFee = $this->calculateFieldsFee();
		foreach ($this->fields as $field)
		{
			if (!$field->visible)
			{
				continue;
			}
			if (!$field->row->fee_field)
			{
				continue;
			}
			if (strtolower($field->type) == 'text' || $field->row->fee_formula)
			{
				//Maybe we need to check fee formula
				if (!$field->row->fee_formula)
				{
					continue;
				}
				else
				{
					$formula = $field->row->fee_formula;
					$formula = str_replace('[FIELD_VALUE]', floatval($field->value), $formula);
					if (count($fieldsFee))
					{
						foreach ($fieldsFee as $fieldName => $fieldFee)
						{
							$fieldName = strtoupper($fieldName);
							$formula = str_replace('[' . $fieldName . ']', $fieldFee, $formula);
						}
					}
					$feeValue = 0;
					if ($formula)
					{
						@eval('$feeValue = ' . $formula . ';');
						$fee += $feeValue;

						//Use the code below if eval is disabled on server
						//$fee += self::calculateFormula($formula);
					}
				}
			}
			else
			{
				$feeValues = explode("\r\n", $field->row->fee_values);
				$values = explode("\r\n", $field->row->values);
				if (is_array($field->value))
				{
					$fieldValues = $field->value;
				}
				elseif ($field->value)
				{
					$fieldValues = array();
					$fieldValues[] = $field->value;
				}
				else
				{
					$fieldValues = array();
				}
				$values = array_map('trim', $values);
				$fieldValues = array_map('trim', $fieldValues);
				for ($j = 0, $m = count($fieldValues); $j < $m; $j++)
				{
					$fieldValue = $fieldValues[$j];
					$fieldValueIndex = array_search($fieldValue, $values);
					if ($fieldValueIndex !== false && isset($feeValues[$fieldValueIndex]))
					{
						$fee += $feeValues[$fieldValueIndex];
					}
				}
			}
		}
		return $fee;
	}

	/**
	 * Calculate the fee associated with each field to use in fee formula
	 *
	 * @return array
	 */
	private function calculateFieldsFee()
	{
		$fieldsFee     = array('form_amount' => $this->amount);
		$feeFieldTypes = array('text', 'radio', 'list', 'checkboxes');
		foreach ($this->fields as $fieldName => $field)
		{
			if (!$field->visible)
			{
				continue;
			}
			$fieldType = strtolower($field->type);
			if (in_array($fieldType, $feeFieldTypes))
			{
				if ($fieldType == 'text')
				{
					$fieldsFee[$fieldName] = floatval($field->value);
				}
				elseif ($fieldType == 'checkboxes' || ($fieldType == 'list' && $field->row->multiple))
				{
					$feeValues = explode("\r\n", $field->row->fee_values);
					$values    = explode("\r\n", $field->row->values);
					$feeAmount = 0;

					if (is_array($field->value))
					{
						$selectedOptions = $field->value;
					}
					elseif (strpos($field->value, "\r\n"))
					{
						$selectedOptions = explode("\r\n", $field->value);
					}
					elseif (is_string($field->value) && is_array(json_decode($field->value)))
					{
						$selectedOptions = json_decode($field->value);
					}
					else
					{
						$selectedOptions = array($field->value);
					}
					if (is_array($selectedOptions))
					{
						foreach ($selectedOptions as $selectedOption)
						{
							$index = array_search($selectedOption, $values);
							if ($index !== false)
							{
								if (isset($feeValues[$index]))
								{
									$feeAmount += floatval($feeValues[$index]);
								}
							}
						}
					}

					$fieldsFee[$fieldName] = $feeAmount;
				}
				else
				{
					$feeValues  = explode("\r\n", $field->row->fee_values);
					$values     = explode("\r\n", $field->row->values);
					$values     = array_map('trim', $values);
					$valueIndex = array_search(trim($field->value), $values);
					if ($valueIndex !== false && isset($feeValues[$valueIndex]))
					{
						$fieldsFee[$fieldName] = $feeValues[$valueIndex];
					}
					else
					{
						$fieldsFee[$fieldName] = 0;
					}
				}
			}
		}

		return $fieldsFee;
	}

	/**
	 * Helper function to calculate fee when eval function is disabled by the hosting
	 * @param string $formula
	 * @return number
	 */
	public static function calculateFormula($formula)
	{
		$formula = trim($formula);     // trim white spaces
		$formula = ereg_replace ('[^0-9\+-\*\/\(\) ]', '', $formula);    // remove any non-numbers chars; exception for math operators
		$compute = create_function("", "return (" . $formula . ");" );
		return 0 + $compute();
	}

	/**
	 * Set the form amount used to generate [FORM_AMOUNT] tag
	 *
	 * @param $amount
	 */
	public function setAmount($amount)
	{
		$this->amount = $amount;
	}
	/**
	 * Render hidden input for form fields
	 */
	public function renderHidden()
	{
		$return = '';
		foreach ($this->fields as $field)
		{
			if (is_array($field->value))
			{
				foreach ($field->value as $value)
				{
					$return .= '<input type="hidden" name="' . $field->name . '[]" value="' . htmlspecialchars($value, ENT_COMPAT, 'UTF-8') . '" />' . "\r\n";
				}
			}
			else
			{
				$return .= '<input type="hidden" name="' . $field->name . '" value="' . htmlspecialchars($field->value, ENT_COMPAT, 'UTF-8') . '" />' . "\r\n";
			}
		}

		return $return;
	}
	/**
	 * Method to get form rendered string 
	 * 
	 * @return string
	 */
	public function render($tableLess = true)
	{
		ob_start();
		foreach ($this->fields as $field)
		{
			echo $field->getControlGroup($tableLess);
		}
		return ob_get_clean();	
	}

    /**
     * Display form fields and it's value
     *
     * @param bool $tableLess
     * @return string
     */
    public function getOutput($tableLess = true)
    {
        ob_start();
        foreach ($this->fields as $field)
        {
            echo $field->getOutput($tableLess);
        }
        return ob_get_clean();
    }
}